"""
TCL script writer for OpenSees binary execution.

Generates .tcl files that can be executed by the OpenSees binary.
"""

from __future__ import annotations

from pathlib import Path
from typing import TextIO

from paz.domain.loads import DistributedLoad, LoadCase, LoadDirection, NodalLoad
from paz.domain.materials import Material
from paz.domain.model import StructuralModel
from paz.domain.model.local_axes import calculate_local_axes
from paz.domain.sections import Section


class TclWriter:
    """Writes OpenSees TCL scripts for structural analysis."""

    def __init__(self, output_dir: Path) -> None:
        """
        Initialize TCL writer.

        Args:
            output_dir: Directory for output files (tcl script and results)
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def write_model(
        self,
        model: StructuralModel,
        materials: dict[str, Material],
        sections: dict[str, Section],
        load_case: LoadCase,
        nodal_loads: list[NodalLoad],
        distributed_loads: list[DistributedLoad],
    ) -> Path:
        """
        Write complete OpenSees model to TCL file.

        Args:
            model: Structural model with nodes and frames
            materials: Materials dictionary
            sections: Sections dictionary
            load_case: Load case being analyzed
            nodal_loads: Nodal loads
            distributed_loads: Distributed loads

        Returns:
            Path to generated TCL file
        """
        tcl_path = self.output_dir / "model.tcl"

        with tcl_path.open("w", encoding="utf-8") as f:
            self._write_header(f, load_case)
            self._write_nodes(f, model)
            self._write_restraints(f, model)
            self._write_elements(f, model, materials, sections)
            self._write_loads(f, nodal_loads, distributed_loads)
            self._write_analysis(f)
            self._write_results_extraction(f, model)

        return tcl_path

    def _write_header(self, f: TextIO, load_case: LoadCase) -> None:
        """Write TCL header and model initialization."""
        f.write("# OpenSees model generated by PAZ\n")
        f.write(f"# Load case: {load_case.name}\n")
        f.write("wipe\n")
        f.write("model Basic -ndm 3 -ndf 6\n\n")
        f.write(f"file mkdir {self.output_dir}\n\n")

    def _write_nodes(self, f: TextIO, model: StructuralModel) -> None:
        """Write node definitions."""
        f.write("# Nodes\n")
        for node in model.nodes:
            f.write(f"node {node.id} {node.x:.6e} {node.y:.6e} {node.z:.6e}\n")
        f.write("\n")

    def _write_restraints(self, f: TextIO, model: StructuralModel) -> None:
        """Write boundary conditions."""
        f.write("# Boundary conditions (restraints)\n")
        for node in model.nodes:
            if not node.restraint.is_free:
                dofs = " ".join(str(int(v)) for v in node.restraint.to_list())
                f.write(f"fix {node.id} {dofs}\n")
        f.write("\n")

    def _write_elements(
        self,
        f: TextIO,
        model: StructuralModel,
        materials: dict[str, Material],
        sections: dict[str, Section],
    ) -> None:
        """Write frame elements with geometric transformations."""
        f.write("# Frame elements\n")

        for frame in model.frames:
            material = materials.get(frame.material_name)
            section = sections.get(frame.section_name)

            if material is None or section is None:
                continue

            # Get nodes for local axes calculation
            node_i = model.get_node(frame.node_i_id)
            node_j = model.get_node(frame.node_j_id)

            # Calculate local axes
            local_axes = calculate_local_axes(node_i, node_j, frame.rotation)
            vecxz = local_axes.axis3

            # Write geometric transformation
            transf_tag = frame.id
            f.write(
                f"geomTransf Linear {transf_tag} "
                f"{vecxz[0]:.6e} {vecxz[1]:.6e} {vecxz[2]:.6e}\n"
            )

            # Get section properties
            A = section.A
            E = material.E
            G = material.G
            J = section.J if section.J is not None else (section.Ix + section.Iy) / 2
            Iy = section.Iy
            Iz = section.Ix  # Strong axis

            # Write element
            # elasticBeamColumn eleTag iNode jNode A E G J Iy Iz transfTag
            f.write(
                f"element elasticBeamColumn {frame.id} "
                f"{frame.node_i_id} {frame.node_j_id} "
                f"{A:.6e} {E:.6e} {G:.6e} {J:.6e} {Iy:.6e} {Iz:.6e} {transf_tag}\n"
            )

        f.write("\n")

    def _write_loads(
        self,
        f: TextIO,
        nodal_loads: list[NodalLoad],
        distributed_loads: list[DistributedLoad],
    ) -> None:
        """Write load patterns."""
        # Pattern for nodal loads
        if nodal_loads:
            f.write("# Nodal loads\n")
            f.write('pattern Plain 1 "Linear" {\n')
            for nodal_load in nodal_loads:
                f.write(
                    f"    load {nodal_load.node_id} "
                    f"{nodal_load.Fx:.6e} {nodal_load.Fy:.6e} {nodal_load.Fz:.6e} "
                    f"{nodal_load.Mx:.6e} {nodal_load.My:.6e} {nodal_load.Mz:.6e}\n"
                )
            f.write("}\n\n")

        # Pattern for distributed loads
        if distributed_loads:
            f.write("# Distributed loads\n")
            f.write('pattern Plain 2 "Linear" {\n')
            for dist_load in distributed_loads:
                wy, wz = self._get_distributed_load_components(dist_load)
                if abs(wy) > 1e-12 or abs(wz) > 1e-12:
                    f.write(
                        f"    eleLoad -ele {dist_load.frame_id} "
                        f"-type -beamUniform {wy:.6e} {wz:.6e}\n"
                    )
            f.write("}\n\n")

    def _get_distributed_load_components(
        self, load: DistributedLoad
    ) -> tuple[float, float]:
        """Convert distributed load to local wy, wz components."""
        w = load.average_intensity

        if load.direction == LoadDirection.GRAVITY:
            return 0.0, -w
        elif load.direction in (LoadDirection.LOCAL_Y, LoadDirection.GLOBAL_Y):
            return w, 0.0
        elif load.direction in (LoadDirection.LOCAL_Z, LoadDirection.GLOBAL_Z):
            return 0.0, w
        else:
            return 0.0, 0.0

    def _write_analysis(self, f: TextIO) -> None:
        """Write analysis commands."""
        f.write("# Analysis configuration\n")
        f.write("constraints Plain\n")
        f.write("numberer RCM\n")
        f.write("system BandGeneral\n")
        f.write("test NormDispIncr 1.0e-6 50\n")
        f.write("algorithm Linear\n")
        f.write("integrator LoadControl 1.0\n")
        f.write("analysis Static\n")
        f.write("set ok [analyze 1]\n")
        f.write("if {$ok != 0} {\n")
        f.write('    puts "PAZ_ANALYSIS_FAILED $ok"\n')
        f.write("}\n\n")

    def _write_results_extraction(self, f: TextIO, _model: StructuralModel) -> None:
        """Write commands to extract and save results."""
        out_dir = str(self.output_dir)

        # Node displacements
        f.write("# Save node displacements\n")
        f.write("set allNodes [getNodeTags]\n")
        f.write(f'set dispFile [open "{out_dir}/node_disp.txt" "w"]\n')
        f.write("foreach n $allNodes {\n")
        f.write("    set u [nodeDisp $n]\n")
        f.write('    puts $dispFile "$n $u"\n')
        f.write("}\n")
        f.write("close $dispFile\n\n")

        # Node reactions
        f.write("# Save node reactions\n")
        f.write("reactions\n")
        f.write(f'set reacFile [open "{out_dir}/node_reactions.txt" "w"]\n')
        f.write("foreach n $allNodes {\n")
        f.write("    set r [nodeReaction $n]\n")
        f.write("    if {[llength $r] > 0} {\n")
        f.write('        puts $reacFile "$n $r"\n')
        f.write("    }\n")
        f.write("}\n")
        f.write("close $reacFile\n\n")

        # Element forces
        f.write("# Save element forces\n")
        f.write("set allEles [getEleTags]\n")
        f.write(f'set eleFile [open "{out_dir}/elem_forces.txt" "w"]\n')
        f.write("foreach e $allEles {\n")
        f.write('    set lf ""\n')
        f.write("    if {[catch {set lf [eleResponse $e localForce]} msg]} {\n")
        f.write("        if {[catch {set lf [eleResponse $e forces]} msg2]} {\n")
        f.write("            catch {set lf [eleResponse $e force]}\n")
        f.write("        }\n")
        f.write("    }\n")
        f.write('    if {$lf ne ""} {\n')
        f.write('        puts $eleFile "$e $lf"\n')
        f.write("    }\n")
        f.write("}\n")
        f.write("close $eleFile\n\n")

        f.write('puts "PAZ_ANALYSIS_COMPLETE"\n')
