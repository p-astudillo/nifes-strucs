"""
Results parser for OpenSees output files.

Reads displacement, reaction, and element force files generated by OpenSees.
"""

from __future__ import annotations

from pathlib import Path

from paz.domain.results import (
    FrameForces,
    FrameResult,
    NodalDisplacement,
    NodalReaction,
)


class ResultsParser:
    """Parses OpenSees output files into domain result objects."""

    def __init__(self, output_dir: Path) -> None:
        """
        Initialize parser.

        Args:
            output_dir: Directory containing OpenSees output files
        """
        self.output_dir = output_dir

    def parse_displacements(self) -> dict[int, NodalDisplacement]:
        """
        Parse node displacement file.

        Expected format: "<node_id> ux uy uz rx ry rz"

        Returns:
            Dictionary mapping node_id to NodalDisplacement
        """
        disp_file = self.output_dir / "node_disp.txt"
        displacements: dict[int, NodalDisplacement] = {}

        if not disp_file.exists():
            return displacements

        text = disp_file.read_text(encoding="utf-8", errors="replace")

        for line in text.splitlines():
            line = line.strip()
            if not line:
                continue

            parts = line.split()
            if len(parts) < 7:  # node_id + 6 DOFs
                continue

            try:
                node_id = int(parts[0])
                ux = float(parts[1])
                uy = float(parts[2])
                uz = float(parts[3])
                rx = float(parts[4])
                ry = float(parts[5])
                rz = float(parts[6])

                displacements[node_id] = NodalDisplacement(
                    node_id=node_id,
                    Ux=ux,
                    Uy=uy,
                    Uz=uz,
                    Rx=rx,
                    Ry=ry,
                    Rz=rz,
                )
            except (ValueError, IndexError):
                continue

        return displacements

    def parse_reactions(self) -> dict[int, NodalReaction]:
        """
        Parse node reactions file.

        Expected format: "<node_id> Fx Fy Fz Mx My Mz"

        Returns:
            Dictionary mapping node_id to NodalReaction
        """
        react_file = self.output_dir / "node_reactions.txt"
        reactions: dict[int, NodalReaction] = {}

        if not react_file.exists():
            return reactions

        text = react_file.read_text(encoding="utf-8", errors="replace")

        for line in text.splitlines():
            line = line.strip()
            if not line:
                continue

            parts = line.split()
            if len(parts) < 7:  # node_id + 6 DOFs
                continue

            try:
                node_id = int(parts[0])
                fx = float(parts[1])
                fy = float(parts[2])
                fz = float(parts[3])
                mx = float(parts[4])
                my = float(parts[5])
                mz = float(parts[6])

                # Only include nodes with non-zero reactions
                if any(abs(v) > 1e-12 for v in [fx, fy, fz, mx, my, mz]):
                    reactions[node_id] = NodalReaction(
                        node_id=node_id,
                        Fx=fx,
                        Fy=fy,
                        Fz=fz,
                        Mx=mx,
                        My=my,
                        Mz=mz,
                    )
            except (ValueError, IndexError):
                continue

        return reactions

    def parse_element_forces(self) -> dict[int, FrameResult]:
        """
        Parse element forces file.

        Expected format: "<elem_id> Ni Vyi Vzi Ti Myi Mzi Nj Vyj Vzj Tj Myj Mzj"
        (12 force components for elasticBeamColumn localForce)

        Returns:
            Dictionary mapping frame_id to FrameResult
        """
        forces_file = self.output_dir / "elem_forces.txt"
        frame_results: dict[int, FrameResult] = {}

        if not forces_file.exists():
            return frame_results

        text = forces_file.read_text(encoding="utf-8", errors="replace")

        for line in text.splitlines():
            line = line.strip()
            if not line:
                continue

            parts = line.split()
            if len(parts) < 13:  # elem_id + 12 forces
                continue

            try:
                elem_id = int(parts[0])
                vals = [float(x) for x in parts[1:13]]

                # Forces at start (i) - location 0.0
                # OpenSees convention: positive P = tension, positive V/M per right-hand rule
                P_i = vals[0]
                V2_i = vals[1]
                V3_i = vals[2]
                T_i = vals[3]
                M2_i = vals[4]
                M3_i = vals[5]

                # Forces at end (j) - location 1.0
                # Sign convention: forces at j are reported in element local coords
                # For equilibrium: P_j = -P_i (if no distributed axial load)
                P_j = -vals[6]
                V2_j = -vals[7]
                V3_j = -vals[8]
                T_j = -vals[9]
                M2_j = -vals[10]
                M3_j = -vals[11]

                forces_i = FrameForces(
                    location=0.0,
                    P=P_i,
                    V2=V2_i,
                    V3=V3_i,
                    T=T_i,
                    M2=M2_i,
                    M3=M3_i,
                )

                forces_j = FrameForces(
                    location=1.0,
                    P=P_j,
                    V2=V2_j,
                    V3=V3_j,
                    T=T_j,
                    M2=M2_j,
                    M3=M3_j,
                )

                # Store only endpoint forces from OpenSees
                # Intermediate points will be computed analytically in AnalysisService
                # using the actual load data for correct parabolic moment diagrams
                frame_results[elem_id] = FrameResult(
                    frame_id=elem_id,
                    forces=[forces_i, forces_j],
                )

            except (ValueError, IndexError):
                continue

        return frame_results

    def check_analysis_success(self, stdout: str) -> bool:
        """
        Check if analysis completed successfully.

        Args:
            stdout: OpenSees stdout output

        Returns:
            True if analysis succeeded
        """
        if "PAZ_ANALYSIS_FAILED" in stdout:
            return False
        if "PAZ_ANALYSIS_COMPLETE" in stdout:
            return True
        # If no explicit marker, check for common error patterns
        return "error" not in stdout.lower() and "failed" not in stdout.lower()
